** Fresher Academy 2018

# 1 ES6
## 1.1 Reference
### 1.1.1 ES6
   Javascript is the term developers use for ECMAScript Language.

   ES6 
   ES6 is the future of Javascript and Web development.
   Atwood's Law: "Any application that can be written in JavaScript, will eventually be written in Javascript".

   ES6 được bổ sung thêm nhiều ý tưởng tiến bộ và là hướng đi của Javascript vì:

   1. Dù ES6 chưa được tương thích đầy đủ với tất cả trình duyệt hiện nay, nhưng có những công cụ như Babel giúp dịch và chuyển đổi tất cả code từ ES6 sang phiên bản ES5. Do đó cho phép lập trình viên có thể tận dụng tất cả tính năng hữu ích của ES6 để lập trình và không phải lo lắng về việc code có tương thích với trình duyệt hay không.
   2. Phiên bản ES6 được tối ưu hóa nâng cao tính hiệu quả và xử lý nhanh hơn so với ES5
   3. ES6 hỗ trợ việc tương thích ngược 100%: Tức là code viết trên ES5 có thể được chạy trên ES6 bình thường
   4. ES6 có các lớp hướng đối tượng
   5. ES6 có arrow functions, cho phép viết code ngắn gọn hơn và hỗ trợ cách sử dụng this thêm tiện lợi
   6. ES6 được tích hợp sẵn các module, cung cấp một phương pháp xác định để tải và xuất các module 
   7. ES6 giải quyết nhiều vấn đề đã tồn tại trong JS trước đây mà thường được xử lý bằng các framework hỗ trợ
   8. ES6 has const and let
   9. ES6 có spread operator
   10. ES6 has Promises: Promises giúp cho các trạng thái bất đồng trong JS trở nên dễ đoán hơn và được xử lý thân thiện hơn
   
### 1.1.2 Javascript Engine
   A 'JavaScript Engine' còn được xem là một loại 'virutal machine'. A virtual machine nói đến sự mô hình hóa hướng phần mềm của một hệ thống máy tính cho trước. Virtual machines được chia làm nhiều loại trong đó có: system virtual machine và process virtual machine. 
   A system virutal machine cung cấp một sự mô hình hóa đầy đủ của một nền tảng mà trên đó một hệ điều hành có thể được thực thi, ví dụ Parallels là một system virtual machine cho phép bạn chạy Windows trên máy Mac. A process virutal machine thì có chức năng ít đầy đủ hơn và có thể chỉ để thực thi một chương trình hay một process, ví dụ Wine là một process virutal machine cho phép bạn chạy các ứng dụng của Windows trên một máy Linux, nhưng nó không cung cấp cả một hệ điều hành Windows chạy trên Linux. 
   A Javascript Engine là một loại process virtual machine được thiết kế riêng để thông dịch và thực thi JS code.
   
   Công việc cơ bản của một JS Engine: lấy JS code mà một dev viết rồi convert nó để tăng tốc độ và tối ưu hóa code, code này sau đó sẽ được thông dịch bởi một trình duyệt hay nhúng vào ứng dụng. 
   
   _ Headless browser : a web browser without a graphic user interface_
   
   Node.js: là một framework hướng sự kiện bất đồng bộ, cho phép bạn sử dụng JS on the sever-side. 
   
   JavaScript Core (a JS engine): có 6 building blocks để analyze, interpret, optimize, and garbage collect JS code.
   JS Core thực hiện một chuỗi các bước để thông dịch và tối ưu hóa a script:
   ```
   1. Phân tích ngữ nghĩa, chia nhỏ source code thành một chuỗi các tokens, hay strings có ý nghĩa xác định.
   2. Các tokens được phân tích bởi bộ phân tích cú pháp (parser) và được đưa vào trong một cây cú pháp
   3. Bốn quy trình JIT (just in time) được kích hoạt, phân tích và thực thi bytecode mà parser đã tạo ra
   ```
   Google’s V8 engine, written in C++, also compiles and executes JavaScript source code, handles memory allocation, and garbage collects leftovers. Its design consists of two compilers that compile source code directly into machine code: 
   ```
   Full-codegen: a fast compiler that produces unoptimized code
   Crankshaft: a slower compiler that produces fast, optimized code.
   If Crankshaft determines that the unoptimized code generated by Full-codegen is in need of optimization, it replaces it, a process known as ‘crankshafting’.
   ```
### 1.1.3 Transpilers
   Transpiler or source-to-source compiler, là công cụ chuyển đổi mã nguồn được viết bằng ngôn ngữ lập trình này sang mã nguồn tương đương trong một ngôn ngữ khác

   * Transpiler cho phép chuyển đổi các ngôn ngữ  target JS (hay compile-to-JS) sang JS để thực thi trong các môi trường JS.
   * Transpiler chuyển đổi code viết trong ES6 sang ES5, nhờ đó có thể chạy các code này trên tất cả trình duyệt chưa hỗ trợ ES6
   * Transpiler cung cấp một nguồn thông tin, phản hồi quan trọng từ các lập trình viên cho các nhà phát triển ECMAScript standard (hay JS); đóng vai trò lớn trong việc định hướng các quyết định của TC39 committee (nhóm chịu trách nhiệm thiết kế ECMAScript standard)

## 1.2 History
### 1.2.1 What's ECMAScript?
   ECMAScript là một bản tiêu chuẩn được đưa ra bởi ECMA International Org, được tạo ra để tiêu chuẩn hóa JavaScript. ECMAScript biểu diễn một tập hợp các tiêu chuẩn dành cho một scripting language.

   JS đã luôn là ngôn ngữ theo tiêu chuẩn ECMAScript được biết đến rộng rãi nhất cho đến nay kể từ khi ECMAScript được ban hành, ngoài ra còn có các ngôn ngữ khác tuân theo ECMAScript như JScript, ActionScript.

### 1.2.2 What is JavaScript Engine ? Can you name a few JavaScript Engine used in some popular Browsers such as Chrome, Firefox, IE
   JS Engine: là một công cụ (virtual machine) cho phép thực thi JS code trên các trình duyệt hay hệ thống khác nhau, lấy JS code mà một dev viết rồi convert nó để tăng tốc độ và tối ưu hóa code, code này sau đó sẽ được thông dịch bởi một trình duyệt hay nhúng vào ứng dụng.   
   
   Chrome: JS engine V8; Firefox: Spidermonkey; IE and Edge: Chakra; Safari: Javascript core; Node.js: V8.

### 1.2.3 What is Future JavaScript ? 
   Future Javacript: JS tương lai sẽ dựa trên nền tảng ES6 standard, ngày càng tăng cường thêm các feature cho phép xử lý tác vụ server-side. Nhờ sự chấp nhận và sử dụng JS ngày càng rộng rãi của các lập trình viên vào thiết kế từ front-end tới back-end đòi hỏi sự tối ưu hóa hơn nữa và tăng cường những tính năng hữu ích, thân thiện hơn khi lập trình OOP, những điều mà đã được đặt nền móng và thực hiện tốt ở ES6.

### 1.2.4 What is problem you have if you want to use Future JavaScript in Present Browsers?
   1. Sự tương thích của ngôn ngữ với trình duyệt: do ngôn ngữ mới được cập nhật, đưa vào các tính năng và cú pháp mới chưa kịp bổ sung và hỗ trợ bởi trình duyệt hiện tại; dẫn đến code không được trình duyệt hiểu đầy đủ và không thể thực thi >> cần một transpiler.

### 1.2.5 What is transpiler ?
   Transpiler or source-to-source compiler, là công cụ chuyển đổi mã nguồn được viết bằng ngôn ngữ lập trình này sang mã nguồn tương đương trong một ngôn ngữ khác.

### 1.2.6 What is Babel ? Try Babel online here: https://babeljs.io/repl/
   Babel là một transpiler cho phép chuyển đổi code được viết trên ES6 sang code tương đương trong ES5.   

## 1.3 Arrow Function
   Arrow function không cho phép tạo ra constructor, arrow function không có biến đặc biệt arguments!

### 1.3.1 Arrow Function Syntax
   // function không có parameter
   () => { statements };
   _ => { statements };

   // function chỉ có một parameter
   (singlepar) => { statements }
   singlepar => { statements }

   // function có nhiều parameters
   (par1, par2, ...) => { statements }
   (par1, par2, ...) => expression;     // equivalent to: (par1, par2, ...) => { return expression; }


### 1.3.2 Compare arrow function syntax to ES5 function syntax ?
   ES5 function syntax: Luôn yêu cầu cú pháp đầy đủ thành phần, chỉ bỏ tên nếu khai báo hàm vô danh. ( function name(para) {} )

   Arrow function syntax: Có nhiều cú pháp hơn, cho phép lược bỏ khi cần thiết để code ngắn gọn và súc tích hơn

### 1.3.3 Arrow function variations, try them in Babel Repl, fix error if any
   ```
    const f1 = () => 10;
    const f2 = x  => 3;
    const f3 = (...x) => 3;
    const f4 = (x, y) => 3;
    const f5 = x => {
    try {
        1;      /// return 1;
    } catch (e) {}
    }
    const f6 = x => { return 10; }
    const f7 = x => { y: x }  /// const f7 = x => ( { y: x } );
   ```
### 1.3.4 True or false: arrow functions are anonymous ?
   ```
   const myFunc = x => 4;
   console.log(myFunc.name);
   ```
   Hàm arrow là hàm vô danh, do trong cú pháp hàm không có chứa tên hàm.
   Ở code trên hàm được lưu vào biến myFunc.

### 1.3.5 this
   Evaluate the code below, can you explain what happens ?
   ```
    var obj = {
    a: 10,
    method: function method() {
        setTimeout(function () {
            console.log(this.a);
        }, 200);
    }
    }

    var obj2 = {
    a: 10,
    method: function method() {
        setTimeout(() => {
            console.log(this.a);
        }, 200);
    }
    }

    obj.method(); // undefined
    obj2.method(); // 10
   ```
   Trường hợp gọi hàm obj.method(); this.a nằm trong một callback function của setTimeout() function do đó hàm callback function được gọi và thực thi theo cách gọi trực tiếp bởi hàm chứa nó là setTimeout() nên this trỏ đến global.

   Trường hợp gọi hàm obj2.method(); this.a nằm trong arrow function, bản thân arrow function không có this của chính nó mà nó nhận this của ngữ cảnh chứa nó (hàm cha của nó) là hàm method(), hàm method ở đây được gọi theo cách 2 nên trỏ đến đối tượng obj2 chứa method.

### 1.3.6 Promise
   Compare 2 Promise call below, what do you think ? If v is null or undefined what will happend ? How you handle that ?
   ```
    p.then(function (v) { return v.id });

    p.then(v => v.id);
   ```
   Hai lệnh đều thực hiện và cho kết quả giống nhau.
   Nếu v là null hay undefined trình duyệt sẽ báo lỗi TypeError, do không có property của null hay undefined.
   Với function bình thường có thể đặt tên cho function, khi có lỗi giúp ta tìm lỗi nhanh chóng hơn để debug.

   Để xử lý trường hợp này ta có thể dùng try catch để bắt lỗi, hoặc dùng if để kiểm tra v trước khi gọi v.id
   ```
    p.then(function (v) { 
    try {
        console.log(v.id);
        return v.id; 
    } catch (e) {}

    }
    );

    p.then(v => {
    try {
        console.log(v.id);
        return v.id; 
    } catch (e) {}

    });
   ```
### 1.3.7 Exercise 01: rewrite all function below with arrow functions and try to avoid curly braces {} as much as possible
   ```
   (() => {
    foo = (x) => {
        var y = x * 2;

        return function (z, baz) {
            if (z.length > 3) {
                return z.map( baz = (v) => {
                if (v > 3) return v + y;
                else return baz( v * 4 );  // list2: 8, 16, 8, 10
                } );
            }
            else {
                var obj = [];

                setTimeout( () => {
                obj.length = 1;
                obj[0] = this.w;
                }, 100 );

                return obj;
            }
        };
    }

    var p = foo( 2 );
    var list1 = [1,3,4];
    var list2 = list1.concat( 6 );

    list1 = p.call( { w: 42 }, list1 ); // list1 = [42]
    list2 = p( list2 ); // list2 = [8, 16, 8, 10];

    setTimeout(  () => console.log( list1[0] === list2.reduce ((s,v) => s + v, 0 ) ), 200 );
    })();
   ```
## 1.4 Block Scope
### 1.4.1 Compare let and var
   Khai báo let giới hạn scope của biến trong một block (giữa hai dấu {}), khai báo let không cho phép hoisting,
chỉ sử dụng được variable từ sau khi biến đã  được khai báo.

   Khai báo var có scope là function scope hoặc toàn cục, cho phép hoisting.

### 1.4.2 Closures scope, how do let work in closures, try example below
   ```
    for (let i = 0; i < 3; i++) {
        let btn = document.getElementById('btn' + i);
        btn.addEventListener('click', () {
            alert(i);
        });
    }
   ```
   Giống như var có scope là function, closure cho phép function nhớ scope của nó khi khai báo biến theo var ngay cả khi nó được gọi ở ngoài vị trí được khai báo.
   
   Khai báo let có scope là block, do đó mỗi vòng lặp for chạy sẽ tạo ra một block scope mới bao quanh scope của callback fuction được gọi khi có 'click' event. Khi callback function được gọi, nó sẽ nhớ block scope của vòng for của btni mà function được gán.
   

### 1.4.3 What is const ? Example ?
   const là một từ khóa khai báo biến, xác định biến đó là một hằng số, nghĩa là nó sẽ không được phép gán lại giá trị sau khi khai báo mà giá trị của biến const được gán ngay tại thời điểm khai báo.
   
   Tuy nhiên nếu giá trị của biến const là một object hay một array thì vẫn có thể thay đổi giá trị của biến thông qua các property và method của nó. 

   Trong cùng scope, biến const không thể trùng tên với một function hay một biến khác
   ```
   const a = 5;
   a = 10; // TypeError
   const arr = [];
   arr.push(5); // 1

   ```    

### 1.4.4 Exercise: fix code below (anywhere) so the console.log will display true
   ```    
    const x = 2;
    let fns = [];

    (function(){
    const x = 5;

    for (let i=0; i<x; i++) {
        fns[i] = () => i; // fns = fns.concat(() => i);  fns.push(() => i);
    }
    })();

    console.log((x * 2) === fns[x*2]()); // true
   ```
